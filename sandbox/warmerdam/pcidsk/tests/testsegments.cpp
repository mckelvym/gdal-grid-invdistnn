/******************************************************************************
 *
 * Purpose:  CPPUnit test for generic segment access and specialized access
 *           to some segment types.
 * 
 ******************************************************************************
 * Copyright (c) 2009
 * PCI Geomatics, 50 West Wilmot Street, Richmond Hill, Ont, Canada
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
 * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ****************************************************************************/

#include "pcidsk.h"
#include "pcidsk_georef.h"
#include "pcidsk_pct.h"
#include "pcidsk_gcp.h"
#include "pcidsk_tex.h"
#include "pcidsk_gcpsegment.h"
#include <cppunit/extensions/HelperMacros.h>

#ifndef WIN32
#include <unistd.h>
#endif

using namespace PCIDSK;

class SegmentsTest : public CppUnit::TestFixture
{
    CPPUNIT_TEST_SUITE( SegmentsTest );
 
    CPPUNIT_TEST( testEltoro );
    CPPUNIT_TEST( testGeoref );
    CPPUNIT_TEST( testPCTRead );
    CPPUNIT_TEST( testPCTWrite );
    CPPUNIT_TEST( testSegDelete );
    CPPUNIT_TEST( testSegUpdate );
    CPPUNIT_TEST( testGCPAdd );
    CPPUNIT_TEST( testGCPWrite );
    CPPUNIT_TEST( testGCPRead );
    CPPUNIT_TEST( testBitmapRead );
    CPPUNIT_TEST( testBitmapWrite );
    CPPUNIT_TEST( testTextRead );
    CPPUNIT_TEST( testTextWrite );
    
    CPPUNIT_TEST_SUITE_END();

public:
    void setUp();
    void tearDown();
    void testEltoro();
    void testGeoref();
    void testPCTRead();
    void testPCTWrite();
    void testSegDelete();
    void testSegUpdate();
    void testGCPAdd();
    void testGCPWrite();
    void testGCPRead();
    void testBitmapRead();
    void testBitmapWrite();
    void testTextRead();
    void testTextWrite();
};

// Registers the fixture into the 'registry'
CPPUNIT_TEST_SUITE_REGISTRATION( SegmentsTest );

void SegmentsTest::setUp()
{
}

void SegmentsTest::tearDown()
{
}

void SegmentsTest::testEltoro()
{
    PCIDSKFile *eltoro;

    eltoro = PCIDSK::Open( "eltoro.pix", "r", NULL );

    CPPUNIT_ASSERT( eltoro != NULL );

    PCIDSKSegment *seg = eltoro->GetSegment( 1 );

    CPPUNIT_ASSERT( seg != NULL );
    CPPUNIT_ASSERT( seg->GetSegmentType() == SEG_GEO );
    CPPUNIT_ASSERT( seg->GetName() == "GEOref" );
    CPPUNIT_ASSERT( seg->GetSegmentNumber() == 1 );
    CPPUNIT_ASSERT( seg->GetDescription() == "Master Georeferencing Segment for File" );

    seg = eltoro->GetSegment( 3 );

    CPPUNIT_ASSERT( seg != NULL );
    CPPUNIT_ASSERT( seg->GetSegmentType() == SEG_LUT );
    CPPUNIT_ASSERT( seg->GetName() == "Equal" );
    CPPUNIT_ASSERT( seg->GetSegmentNumber() == 3 );

    std::vector<std::string> history = seg->GetHistoryEntries();
    CPPUNIT_ASSERT( history[0] == "FUN    :Input channel =  1 Func = EQUA                          17:25 11Apr2009" );
    CPPUNIT_ASSERT( history[1] == "" );

    delete eltoro;
}

void SegmentsTest::testGeoref()
{
    PCIDSKFile *eltoro;

    eltoro = PCIDSK::Open( "eltoro.pix", "r", NULL );

    CPPUNIT_ASSERT( eltoro != NULL );

    PCIDSKSegment *seg = eltoro->GetSegment( 1 );

    CPPUNIT_ASSERT( seg != NULL );

    PCIDSKGeoref *georef = dynamic_cast<PCIDSKGeoref*>(seg);

    CPPUNIT_ASSERT( georef != NULL );

    CPPUNIT_ASSERT( georef->GetGeosys() == "UTM    11 S E000" );

    double a1, a2, xrot, b1, yrot, b3;

    georef->GetTransform( a1, a2, xrot, b1, yrot, b3 );

    CPPUNIT_ASSERT( a1 == 430640.0 );
    CPPUNIT_ASSERT( a2 == 10.0 );
    CPPUNIT_ASSERT( xrot == 0.0 );
    CPPUNIT_ASSERT( b1 == 3732300.0 );
    CPPUNIT_ASSERT( yrot == 0.0);
    CPPUNIT_ASSERT( b3 == -10.0 );
    
    delete eltoro;
}

void SegmentsTest::testPCTRead()
{
    PCIDSKFile *file;

    file = PCIDSK::Open( "irvine.pix", "r", NULL );

    CPPUNIT_ASSERT( file != NULL );

    PCIDSKSegment *seg = file->GetSegment( 7 );

    CPPUNIT_ASSERT( seg != NULL );

    PCIDSK_PCT *pct_seg = dynamic_cast<PCIDSK_PCT*>(seg);

    CPPUNIT_ASSERT( pct_seg != NULL );

    unsigned char pct[768];

    pct_seg->ReadPCT( pct );

    CPPUNIT_ASSERT( pct[0] == 0 );
    CPPUNIT_ASSERT( pct[255] == 255 );
    CPPUNIT_ASSERT( pct[767] == 255 );
    
    delete file;
}

void SegmentsTest::testPCTWrite()
{
    eChanType channel_types[1] = {CHN_8U};
    PCIDSKFile *file = 
        PCIDSK::Create( "pct_file.pix", 50, 40, 1, channel_types, "BAND", NULL);

    CPPUNIT_ASSERT( file != NULL );

    int iSeg = file->CreateSegment( "TSTPCT", "Desc", SEG_PCT, 0 );

    PCIDSKSegment *seg = file->GetSegment( iSeg );

    CPPUNIT_ASSERT( seg != NULL );

    PCIDSK_PCT *pct_seg = dynamic_cast<PCIDSK_PCT*>(seg);

    CPPUNIT_ASSERT( pct_seg != NULL );

    unsigned char pct[768], pct2[768];
    int i;

    for( i = 0; i < 256; i++ )
    {
        pct[i] = i;
        pct[256+i] = 255-i;;
        pct[512+i] = i/2;
    }
    pct_seg->WritePCT( pct );

    pct_seg->ReadPCT( pct2 );

    CPPUNIT_ASSERT( pct[0] == 0 );
    CPPUNIT_ASSERT( pct[255] == 255 );
    CPPUNIT_ASSERT( pct[767] == 127 );

    delete file;
    unlink( "pct_file.pix" );
}

// Test updating description and history on a segment.

void SegmentsTest::testSegUpdate()
{
    eChanType channel_types[1] = {CHN_8U};
    PCIDSKFile *file = 
        PCIDSK::Create( "pct_file.pix", 50, 40, 1, channel_types, "BAND", NULL);

    CPPUNIT_ASSERT( file != NULL );

    int iSeg = file->CreateSegment( "TSTPCT", "Desc", SEG_PCT, 0 );

    PCIDSKSegment *seg = file->GetSegment( iSeg );

    CPPUNIT_ASSERT( seg != NULL );

    CPPUNIT_ASSERT( seg->GetDescription() == "Desc" );

    seg->SetDescription( "New Description that is too long to really entirely fit in the space available." );
    
    CPPUNIT_ASSERT( seg->GetDescription() == "New Description that is too long to really entirely fit in the s" );

    seg->PushHistory( "test_main", "Just testing history" );
    seg->PushHistory( "X", "More recent, yet very long history that will have to be truncated to fit the space." );

    std::vector<std::string> history = seg->GetHistoryEntries();
    
    CPPUNIT_ASSERT( strncmp(history[0].c_str(), 
                            "X      :More recent, yet very long history that will have to be 15:44  ", 
                            64 ) == 0 );

    CPPUNIT_ASSERT( strncmp(history[1].c_str(), 
                            "test_ma:Just testing history                                    ", 
                            64 ) == 0 );
    CPPUNIT_ASSERT( history[1][75] == '2' ); // first char of year.

    delete file;

    unlink( "pct_file.pix" );
}

void SegmentsTest::testSegDelete()
{
    eChanType channel_types[1] = {CHN_8U};
    PCIDSKFile *file = 
        PCIDSK::Create( "pct_file.pix", 50, 40, 1, channel_types, "BAND", NULL);

    CPPUNIT_ASSERT( file != NULL );

    int iSeg = file->CreateSegment( "TSTPCT", "Desc", SEG_PCT, 0 );

    PCIDSKSegment *seg = file->GetSegment( iSeg );

    CPPUNIT_ASSERT( seg != NULL );

    PCIDSK_PCT *pct_seg = dynamic_cast<PCIDSK_PCT*>(seg);

    CPPUNIT_ASSERT( pct_seg != NULL );

    unsigned char pct[768];
    int i;

    for( i = 0; i < 256; i++ )
    {
        pct[i] = i;
        pct[256+i] = 255-i;;
        pct[512+i] = i/2;
    }
    pct_seg->WritePCT( pct );
    seg->SetMetadataValue( "TEST", "VALUE" );

    file->DeleteSegment( iSeg );

    delete file;

    file = PCIDSK::Open( "pct_file.pix", "r+", NULL );

    CPPUNIT_ASSERT( file->GetSegment( iSeg ) == NULL );

    delete file;

    unlink( "pct_file.pix" );
}

void SegmentsTest::testGCPAdd()
{
    eChanType channel_types[1] = { CHN_8U };
    PCIDSKFile* file = 
        PCIDSK::Create("gcp_file.pix", 50, 50, 1, channel_types, "BAND");
    delete file;

    file = 
        PCIDSK::Open("gcp_file.pix", "r+");
    
    int segnum = file->CreateSegment("GCP2TEST", "GCP2 Test Segment", SEG_GCP2, 0);
    PCIDSKSegment* seg = file->GetSegment(segnum);
    CPPUNIT_ASSERT(seg != NULL);
    PCIDSKGCPSegment* gcp_seg = dynamic_cast<PCIDSKGCPSegment*>(seg);
    CPPUNIT_ASSERT(gcp_seg != NULL);
    
    CPPUNIT_ASSERT(gcp_seg->GetGCPCount() == 0);
    
    delete file;
    unlink("gcp_file.pix");
}

void SegmentsTest::testGCPWrite()
{
    eChanType channel_types[1] = { CHN_8U };
    PCIDSKFile* file = 
        PCIDSK::Create("gcp_file.pix", 50, 50, 1, channel_types, "BAND");
    delete file;

    file = 
        PCIDSK::Open("gcp_file.pix", "r+");
        
    // Get the GCP segment
    int seg_num = file->CreateSegment("GCP2TEST", "GCP2 Test write", SEG_GCP2, 0);
    PCIDSKSegment* seg = file->GetSegment(seg_num);
    
    CPPUNIT_ASSERT(seg != NULL);
    
    PCIDSKGCPSegment* gcp_seg = dynamic_cast<PCIDSKGCPSegment*>(seg);
    
    CPPUNIT_ASSERT(gcp_seg != NULL);
    
    std::vector<PCIDSK::GCP> gcps;
    
    // Create a few GCPs
    for (unsigned int y = 0; y <= 50; y += 10) {
        for (unsigned int x = 0; x <= 50; x += 10) {
            std::stringstream ss;
            ss << "GCP #" << y * x;
            PCIDSK::GCP gcp(x, y, 1.0,
                x, y, ss.str(), "LAT/LONG D000");
            gcps.push_back(gcp);
        }
    }
    
    // Write out some GCPs
    gcp_seg->SetGCPs(gcps);
    
    CPPUNIT_ASSERT(gcp_seg->GetGCPCount() == gcps.size());
    
    // Read the GCPs back
    std::vector<PCIDSK::GCP> const& gcps_read = gcp_seg->GetGCPs();
    
    CPPUNIT_ASSERT(gcps_read.size() == gcps.size());
    
    delete file;
    
    file = PCIDSK::Open("gcp_file.pix", "r");
    CPPUNIT_ASSERT(file != NULL);
    seg = file->GetSegment(seg_num);
    CPPUNIT_ASSERT(seg != NULL);
    gcp_seg = dynamic_cast<PCIDSKGCPSegment*>(seg);
    CPPUNIT_ASSERT(gcp_seg != NULL);
    CPPUNIT_ASSERT(gcp_seg->GetGCPCount() == gcps.size());
    
    delete file;
    unlink("gcp_file.pix");
}

void SegmentsTest::testGCPRead()
{
    PCIDSKFile* file =
        PCIDSK::Open("irvine_gcp2.pix", "r+");
    
    CPPUNIT_ASSERT(file != NULL);
    
    // Get irvine's GCP2 segment
    PCIDSKSegment* seg = file->GetSegment(9);
    
    CPPUNIT_ASSERT(seg != NULL);
    
    PCIDSKGCPSegment* gcp_seg = dynamic_cast<PCIDSKGCPSegment*>(seg);
    
    CPPUNIT_ASSERT(gcp_seg != NULL);
    
    // Get the GCPs
    std::vector<PCIDSK::GCP> const& gcps_read = gcp_seg->GetGCPs();
    
    CPPUNIT_ASSERT(gcps_read.size() == 22);
    
    delete file;
}

void SegmentsTest::testBitmapRead()

{
    PCIDSKFile* file = PCIDSK::Open("irvine.pix", "r");
    
    CPPUNIT_ASSERT(file != NULL);
    
    // Get bitmap segment.
    PCIDSKSegment* seg = file->GetSegment(10);
    
    CPPUNIT_ASSERT(seg != NULL);

    PCIDSKChannel  *bitmap = dynamic_cast<PCIDSKChannel*>(seg);
    
    CPPUNIT_ASSERT(bitmap != NULL);

    // Confirm expected sizes.

    CPPUNIT_ASSERT( bitmap->GetType() == CHN_BIT );
    CPPUNIT_ASSERT( bitmap->GetWidth() == 512 );
    CPPUNIT_ASSERT( bitmap->GetHeight() == 512 );
    CPPUNIT_ASSERT( bitmap->GetBlockWidth() == 512 );
    CPPUNIT_ASSERT( bitmap->GetBlockHeight() == 8 );
    CPPUNIT_ASSERT( bitmap->GetBlockCount() == 64 );
    CPPUNIT_ASSERT( bitmap->GetOverviewCount() == 0 );

    // Confirm the channel machinery is working.
    CPPUNIT_ASSERT( bitmap->GetDescription() 
                    == "Training site for type 2 water" );

    // Fetch all the data and do a sort of checksum.
    unsigned char data[512];
    uint64 checksum = 0;

    for( int i = 0; i < bitmap->GetBlockCount(); i++ )
    {
        bitmap->ReadBlock( i, data );

        for( unsigned int j = 0; j < sizeof(data); j++ )
            checksum += (i+j+1) * data[j];
    }

    CPPUNIT_ASSERT( checksum == 1256278 );

    // Test a windowed read.
    data[2] = 0;

    bitmap->ReadBlock( 9, data, 96, 4, 5, 3 );
    CPPUNIT_ASSERT( data[0] == 255 && data[1] == 184 );
    CPPUNIT_ASSERT( data[2] == 0 );
    
    delete file;
}

void SegmentsTest::testBitmapWrite()

{
    PCIDSKFile* file = 
        PCIDSK::Create("bitmap_file.pix", 50, 50, 0, NULL, "PIXEL");
        
    // Get the GCP segment
    int seg_num = file->CreateSegment("BIT_TEST", "Bitmap Test write", 
                                      SEG_BIT, 0);

    PCIDSKSegment* seg = file->GetSegment(seg_num);
    
    CPPUNIT_ASSERT(seg != NULL);
    
    PCIDSKChannel* bitmap = dynamic_cast<PCIDSKChannel*>(seg);
    
    CPPUNIT_ASSERT(bitmap != NULL);

    // Confirm expected sizes.

    CPPUNIT_ASSERT( bitmap->GetType() == CHN_BIT );
    CPPUNIT_ASSERT( bitmap->GetWidth() == 50 );
    CPPUNIT_ASSERT( bitmap->GetHeight() == 50 );
    CPPUNIT_ASSERT( bitmap->GetBlockWidth() == 50 );
    CPPUNIT_ASSERT( bitmap->GetBlockHeight() == 8 );
    CPPUNIT_ASSERT( bitmap->GetBlockCount() == 7 );
    CPPUNIT_ASSERT( bitmap->GetOverviewCount() == 0 );

    // Write simple bitmap block.
    unsigned char data[50];
    unsigned int  i;

    for( i = 0; i < sizeof(data); i++ )
        data[i] = i;

    bitmap->WriteBlock( 2, data );

    // Confirm unwritten block is all zeros.
    bitmap->ReadBlock( 3, data );

    for( i = 0; i < sizeof(data); i++ )
        CPPUNIT_ASSERT( data[i] == 0 );

    // Confirm written block is as expected
    bitmap->ReadBlock( 2, data );

    for( i = 0; i < sizeof(data); i++ )
        CPPUNIT_ASSERT( data[i] == i );

    delete file;

    unlink( "bitmap_file.pix" );
}

void SegmentsTest::testTextRead()
{
    PCIDSKFile *file;

    file = PCIDSK::Open( "irvine.pix", "r", NULL );

    CPPUNIT_ASSERT( file != NULL );

    PCIDSKSegment *seg = file->GetSegment( 30 );

    CPPUNIT_ASSERT( seg != NULL );

    PCIDSK_TEX *tex_seg = dynamic_cast<PCIDSK_TEX*>(seg);

    CPPUNIT_ASSERT( tex_seg != NULL );

    std::string text = tex_seg->ReadText();

    CPPUNIT_ASSERT( text.size() == 1480 );
    CPPUNIT_ASSERT( text.substr(0,30) == " !\n !	Attribute data tocreate " );
    
    delete file;
}

void SegmentsTest::testTextWrite()
{
    eChanType channel_types[1] = {CHN_8U};
    PCIDSKFile *file = 
        PCIDSK::Create( "text_file.pix", 50, 40, 0, channel_types, "BAND",NULL);

    CPPUNIT_ASSERT( file != NULL );

    int iSeg = file->CreateSegment( "TSTTEX", "Desc", SEG_TEX, 0 );

    PCIDSKSegment *seg = file->GetSegment( iSeg );

    CPPUNIT_ASSERT( seg != NULL );
    CPPUNIT_ASSERT( seg->GetContentSize() == 32768 );

    PCIDSK_TEX *tex_seg = dynamic_cast<PCIDSK_TEX*>(seg);

    CPPUNIT_ASSERT( tex_seg != NULL );

    std::string text;

    text = "\n\rabc\r\ndef\nxxx\ryyy";

    tex_seg->WriteText( text );

    std::string text2 = tex_seg->ReadText();

    CPPUNIT_ASSERT( text2 == "\nabc\ndef\nxxx\nyyy\n" );

    delete file;
    unlink( "text_file.pix" );
}

